#!/usr/bin/env bash
set -euo pipefail

# Complete script to extract organization domain from cim-domain

# Color codes
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m'

print_status() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Check we're in the right directory
if [ ! -f "Cargo.toml" ] || [ ! -d "cim-domain" ]; then
    print_error "This script must be run from the alchemist repository root"
    exit 1
fi

# Create temporary directory for the new module
TEMP_DIR=$(mktemp -d)
print_status "Working in temporary directory: $TEMP_DIR"

# Clone the repository
cd "$TEMP_DIR"
git clone https://github.com/TheCowboyAI/cim-domain-organization.git
cd cim-domain-organization

# Create directory structure
mkdir -p src

# Create Cargo.toml
cat > Cargo.toml << 'EOF'
[package]
name = "cim-domain-organization"
version = "0.1.0"
edition = "2021"

[dependencies]
# Core dependencies
cim-core-domain = { path = "../cim-core-domain" }
uuid = { version = "1.11", features = ["v4", "serde"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
chrono = { version = "0.4", features = ["serde"] }
thiserror = "2.0"

# Bevy dependencies (optional)
bevy_ecs = { version = "0.16", optional = true }

[features]
default = []
bevy = ["bevy_ecs"]

[dev-dependencies]
tokio = { version = "1.42", features = ["full"] }
EOF

# Copy organization.rs
print_status "Extracting organization aggregate..."
cp /git/thecowboyai/alchemist/cim-domain/src/organization.rs src/organization.rs

# Create lib.rs with proper exports
cat > src/lib.rs << 'EOF'
//! Organization domain for CIM
//!
//! This module contains all organization-related domain logic including:
//! - Organization aggregate and components
//! - Organization commands and events
//! - Organization command and query handlers

pub mod organization;

// Re-export everything from organization module
pub use organization::*;

// Import necessary types from cim-core-domain
use cim_core_domain::{
    AggregateRoot, Component, DomainError, DomainResult,
    EntityId, Command, CommandHandler, CommandEnvelope, CommandAcknowledgment,
    Query, QueryHandler, DomainEvent,
};

use serde::{Deserialize, Serialize};
use uuid::Uuid;

// Organization Commands

/// Create a new organization
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreateOrganization {
    /// Organization's unique ID (generated by caller)
    pub organization_id: Uuid,
    /// Name of the organization
    pub name: String,
    /// Type of organization
    pub org_type: OrganizationType,
    /// Parent organization ID (if this is a sub-organization)
    pub parent_id: Option<Uuid>,
    /// Primary location ID
    pub primary_location_id: Option<Uuid>,
}

impl Command for CreateOrganization {
    type Aggregate = Organization;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(self.organization_id))
    }
}

/// Add a member to an organization
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AddOrganizationMember {
    /// Organization ID
    pub organization_id: Uuid,
    /// Person ID to add as member
    pub person_id: Uuid,
    /// Role to assign
    pub role: OrganizationRole,
    /// Who this person reports to (if applicable)
    pub reports_to: Option<Uuid>,
}

impl Command for AddOrganizationMember {
    type Aggregate = Organization;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(self.organization_id))
    }
}

// Organization Events

/// Organization was created
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OrganizationCreated {
    /// The unique identifier of the organization
    pub organization_id: Uuid,
    /// The name of the organization
    pub name: String,
    /// The type of organization (e.g., Company, Department, Team)
    pub org_type: OrganizationType,
    /// The parent organization ID if this is a sub-organization
    pub parent_id: Option<Uuid>,
    /// The primary location ID for this organization
    pub primary_location_id: Option<Uuid>,
    /// When the organization was created
    pub created_at: chrono::DateTime<chrono::Utc>,
}

impl DomainEvent for OrganizationCreated {
    fn aggregate_id(&self) -> Uuid {
        self.organization_id
    }

    fn event_type(&self) -> &'static str {
        "OrganizationCreated"
    }

    fn subject(&self) -> String {
        format!("organizations.organization.created.v1")
    }
}

/// Member was added to organization
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OrganizationMemberAdded {
    /// The organization receiving the new member
    pub organization_id: Uuid,
    /// The person being added as a member
    pub person_id: Uuid,
    /// The role assigned to the member in this organization
    pub role: OrganizationRole,
    /// The ID of the person this member reports to (if applicable)
    pub reports_to: Option<Uuid>,
    /// When the member joined the organization
    pub joined_at: chrono::DateTime<chrono::Utc>,
}

impl DomainEvent for OrganizationMemberAdded {
    fn aggregate_id(&self) -> Uuid {
        self.organization_id
    }

    fn event_type(&self) -> &'static str {
        "OrganizationMemberAdded"
    }

    fn subject(&self) -> String {
        format!("organizations.organization.member_added.v1")
    }
}

// Organization Queries

/// Query to get organization hierarchy
#[derive(Debug, Clone)]
pub struct GetOrganizationHierarchy {
    /// The root organization ID to start from
    pub organization_id: Uuid,
    /// Maximum depth to traverse (None = unlimited)
    pub max_depth: Option<usize>,
}

impl Query for GetOrganizationHierarchy {}

/// Organization view for queries
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OrganizationView {
    /// Organization's unique identifier
    pub organization_id: Uuid,
    /// Name of the organization
    pub name: String,
    /// Type of organization
    pub org_type: OrganizationType,
    /// Status of the organization
    pub status: OrganizationStatus,
    /// Parent organization ID
    pub parent_id: Option<Uuid>,
    /// Child organization IDs
    pub child_units: Vec<Uuid>,
    /// Member count
    pub member_count: usize,
    /// Primary location name
    pub primary_location_name: Option<String>,
}

/// Hierarchical organization view
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OrganizationHierarchyView {
    /// The organization at this level
    pub organization: OrganizationView,
    /// Child organizations
    pub children: Vec<OrganizationHierarchyView>,
}

// Add more organization-related events as needed...

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_organization_creation() {
        let org = Organization::new(
            "Acme Corp".to_string(),
            OrganizationType::Company,
        );

        assert_eq!(org.name(), "Acme Corp");
        assert_eq!(org.org_type(), &OrganizationType::Company);
        assert_eq!(org.status(), &OrganizationStatus::Active);
    }

    #[test]
    fn test_add_member() {
        let mut org = Organization::new(
            "Tech Team".to_string(),
            OrganizationType::Team,
        );

        let member = OrganizationMember {
            person_id: Uuid::new_v4(),
            role: OrganizationRole::Member,
            reports_to: None,
            joined_at: chrono::Utc::now(),
        };

        assert!(org.add_member(member).is_ok());
        assert_eq!(org.members().len(), 1);
    }
}
EOF

# Create README
cat > README.md << 'EOF'
# CIM Domain - Organization

Organization bounded context for the Composable Information Machine.

## Overview

This module contains all organization-related domain logic including:
- Organization aggregate with hierarchical structure
- Organization membership and roles
- Organization metadata and status
- Command and query handlers for organization operations

## Structure

- `Organization` - The main aggregate root for organizations
- `OrganizationMember` - Value object representing a member of an organization
- `OrganizationType` - Enum for different types of organizations (Company, Department, Team, etc.)
- `OrganizationStatus` - Enum for organization lifecycle states
- `OrganizationRole` - Enum for member roles within an organization

## Commands

- `CreateOrganization` - Create a new organization
- `AddOrganizationMember` - Add a person as a member of an organization

## Events

- `OrganizationCreated` - Emitted when an organization is created
- `OrganizationMemberAdded` - Emitted when a member is added to an organization

## Usage

```rust
use cim_domain_organization::{
    Organization, CreateOrganization, OrganizationType,
    OrganizationCommandHandler
};
use uuid::Uuid;

// Create a new organization
let cmd = CreateOrganization {
    organization_id: Uuid::new_v4(),
    name: "Acme Corp".to_string(),
    org_type: OrganizationType::Company,
    parent_id: None,
    primary_location_id: None,
};

// Process through command handler
handler.handle(cmd).await?;
```

## Features

- `bevy`: Enable Bevy ECS integration for visualization

## License

See the main CIM repository for license information.
EOF

# Initialize git and commit
git init
git add .
git commit -m "Initial organization domain extraction from cim-domain"

# Push to GitHub
git remote add origin https://github.com/TheCowboyAI/cim-domain-organization.git
git push -u origin main --force

print_status "Organization domain extracted successfully!"
print_status "Repository created at: https://github.com/TheCowboyAI/cim-domain-organization"

# Return to original directory
cd /git/thecowboyai/alchemist

# Add as submodule
print_status "Adding organization domain as submodule..."
git submodule add https://github.com/TheCowboyAI/cim-domain-organization.git cim-domain-organization

print_status "Organization domain extraction complete!"
print_status "Next steps:"
print_status "1. Remove organization code from cim-domain"
print_status "2. Update cim-domain exports"
print_status "3. Update Cargo.toml workspace members"
print_status "4. Test the build"
