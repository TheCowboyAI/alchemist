#!/bin/bash
set -e

echo "Extracting Location Domain from cim-domain to cim-domain-location"

# Create the new domain directory structure
echo "Creating cim-domain-location directory structure..."
mkdir -p cim-domain-location/{src/{aggregate,commands,events,handlers,projections,queries,value_objects},tests}

# Create Cargo.toml
echo "Creating Cargo.toml..."
cat > cim-domain-location/Cargo.toml << 'EOF'
[package]
name = "cim-domain-location"
version = "0.1.0"
edition = "2021"
authors = ["The CowboyAI Team"]
description = "Location domain for the Composable Information Machine"
license = "MIT OR Apache-2.0"
repository = "https://github.com/thecowboyai/cim-domain-location"
keywords = ["location", "domain", "ddd", "event-sourcing", "cim"]
categories = ["data-structures", "asynchronous"]

[dependencies]
# Core dependencies
cim-core-domain = { path = "../cim-core-domain" }
cim-infrastructure = { path = "../cim-infrastructure" }

# Async runtime
tokio = { version = "1.41", features = ["full"] }
async-trait = "0.1"

# Serialization
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

# Error handling
thiserror = "2.0"
anyhow = "1.0"

# UUID generation
uuid = { version = "1.11", features = ["v4", "serde"] }

# Time handling
chrono = { version = "0.4", features = ["serde"] }

# Collections
indexmap = "2.7"

[dev-dependencies]
tokio-test = "0.4"
proptest = "1.6"
EOF

# Create README.md
echo "Creating README.md..."
cat > cim-domain-location/README.md << 'EOF'
# CIM Domain Location

Location domain for the Composable Information Machine (CIM).

This crate provides location-related functionality including:
- Location aggregate with physical, virtual, and logical location types
- Address and geographic coordinate value objects
- Location commands and events
- Location command handlers

## Features

- **Location Types**: Physical, Virtual, Logical, and Hybrid locations
- **Address Management**: Full address validation and formatting
- **Geographic Coordinates**: Support for lat/long with distance calculations
- **Virtual Locations**: Platform-based virtual location support
- **Hierarchical Locations**: Parent-child location relationships

## Usage

```rust
use cim_domain_location::{Location, LocationType, Address, GeoCoordinates};

// Create a physical location with address
let address = Address::new(
    "123 Main St".to_string(),
    "Springfield".to_string(),
    "IL".to_string(),
    "USA".to_string(),
    "62701".to_string(),
);

let location = Location::new_physical(
    location_id,
    "Office Building".to_string(),
    address,
)?;

// Create a location with coordinates
let coords = GeoCoordinates::new(40.7128, -74.0060);
let location = Location::new_from_coordinates(
    location_id,
    "NYC Office".to_string(),
    coords,
)?;
```

## License

Licensed under either of:
- Apache License, Version 2.0 ([LICENSE-APACHE](LICENSE-APACHE))
- MIT license ([LICENSE-MIT](LICENSE-MIT))

at your option.
EOF

# Move location aggregate and value objects
echo "Moving location aggregate and value objects..."
mv cim-domain/src/location.rs cim-domain-location/src/aggregate/location.rs

# Create aggregate mod.rs
cat > cim-domain-location/src/aggregate/mod.rs << 'EOF'
//! Location aggregate

mod location;

pub use location::*;
EOF

# Extract location commands
echo "Extracting location commands..."
cat > cim-domain-location/src/commands/mod.rs << 'EOF'
//! Location commands

mod commands;

pub use commands::*;
EOF

# We'll need to manually extract the DefineLocation command from cim-domain/src/commands.rs
# For now, create a placeholder
cat > cim-domain-location/src/commands/commands.rs << 'EOF'
//! Location commands

use crate::{LocationType, Address, GeoCoordinates, VirtualLocation};
use cim_core_domain::{Command, entity::EntityId};
use serde::{Deserialize, Serialize};
use uuid::Uuid;

/// Define a new location
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DefineLocation {
    /// Location's unique ID (generated by caller)
    pub location_id: Uuid,
    /// Location name
    pub name: String,
    /// Location type (physical, virtual, logical, hybrid)
    pub location_type: LocationType,
    /// Physical address (for physical locations)
    pub address: Option<Address>,
    /// Geographic coordinates (for physical locations)
    pub coordinates: Option<GeoCoordinates>,
    /// Virtual location details (for virtual locations)
    pub virtual_location: Option<VirtualLocation>,
    /// Parent location (for hierarchies)
    pub parent_id: Option<Uuid>,
}

/// Marker for location aggregate
#[derive(Debug)]
pub struct LocationAggregate;

impl Command for DefineLocation {
    type Aggregate = LocationAggregate;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(self.location_id))
    }
}
EOF

# Extract location events
echo "Extracting location events..."
cat > cim-domain-location/src/events/mod.rs << 'EOF'
//! Location events

mod events;

pub use events::*;
EOF

# Create events.rs with LocationDefined event
cat > cim-domain-location/src/events/events.rs << 'EOF'
//! Location domain events

use crate::{LocationType, Address, GeoCoordinates, VirtualLocation};
use cim_core_domain::DomainEvent;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

/// Location defined
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LocationDefined {
    /// The unique identifier of the location
    pub location_id: Uuid,
    /// The name of the location
    pub name: String,
    /// The type of location (physical, virtual, etc.)
    pub location_type: LocationType,
    /// The physical address (if applicable)
    pub address: Option<Address>,
    /// The geographic coordinates (if applicable)
    pub coordinates: Option<GeoCoordinates>,
    /// Virtual location details (if applicable)
    pub virtual_location: Option<VirtualLocation>,
    /// The parent location ID (for hierarchical locations)
    pub parent_id: Option<Uuid>,
}

impl DomainEvent for LocationDefined {
    fn aggregate_id(&self) -> Uuid {
        self.location_id
    }

    fn event_type(&self) -> &'static str {
        "LocationDefined"
    }

    fn subject(&self) -> String {
        format!("location.{}.defined", self.location_id)
    }
}
EOF

# Create handlers directory
echo "Creating handlers..."
cat > cim-domain-location/src/handlers/mod.rs << 'EOF'
//! Location command and event handlers

mod location_command_handler;

pub use location_command_handler::*;
EOF

# Create a placeholder for LocationCommandHandler
cat > cim-domain-location/src/handlers/location_command_handler.rs << 'EOF'
//! Location command handler

use crate::{Location, DefineLocation, LocationDefined};
use cim_core_domain::{
    CommandHandler, CommandEnvelope, CommandAcknowledgment, CommandStatus,
    AggregateRepository, EventPublisher,
};
use async_trait::async_trait;
use std::sync::Arc;

/// Handles location-related commands
pub struct LocationCommandHandler<R: AggregateRepository<Location>> {
    repository: Arc<R>,
    event_publisher: Arc<dyn EventPublisher>,
}

impl<R: AggregateRepository<Location>> LocationCommandHandler<R> {
    /// Create a new location command handler
    pub fn new(repository: Arc<R>, event_publisher: Arc<dyn EventPublisher>) -> Self {
        Self {
            repository,
            event_publisher,
        }
    }
}

#[async_trait]
impl<R: AggregateRepository<Location>> CommandHandler<DefineLocation> for LocationCommandHandler<R> {
    async fn handle(&mut self, command: CommandEnvelope<DefineLocation>) -> CommandAcknowledgment {
        // TODO: Implement command handling logic
        CommandAcknowledgment {
            command_id: command.id,
            status: CommandStatus::Accepted,
            message: Some("Location definition command accepted".to_string()),
        }
    }
}
EOF

# Create value_objects module
echo "Creating value objects module..."
cat > cim-domain-location/src/value_objects/mod.rs << 'EOF'
//! Location value objects

// Value objects are defined in the aggregate module for now
// This module is reserved for future value object extractions
EOF

# Create main lib.rs
echo "Creating lib.rs..."
cat > cim-domain-location/src/lib.rs << 'EOF'
//! Location domain for the Composable Information Machine
//!
//! This crate provides location-related functionality including:
//! - Physical locations with addresses and coordinates
//! - Virtual locations on various platforms
//! - Logical locations for organizational structures
//! - Hierarchical location relationships

pub mod aggregate;
pub mod commands;
pub mod events;
pub mod handlers;
pub mod value_objects;

// Re-export main types
pub use aggregate::*;
pub use commands::*;
pub use events::*;
pub use handlers::*;

// Re-export core domain types that are commonly used
pub use cim_core_domain::{
    DomainError, DomainEvent, Command, CommandEnvelope,
    AggregateRepository, EventPublisher, CommandHandler, CommandAcknowledgment,
};
EOF

# Create a basic test
echo "Creating tests..."
cat > cim-domain-location/tests/location_tests.rs << 'EOF'
//! Integration tests for location domain

use cim_domain_location::{
    Location, LocationType, Address, GeoCoordinates,
    DefineLocation, LocationDefined,
};
use cim_core_domain::entity::EntityId;

#[test]
fn test_location_creation() {
    let location_id = EntityId::new();

    let address = Address::new(
        "123 Main St".to_string(),
        "Springfield".to_string(),
        "IL".to_string(),
        "USA".to_string(),
        "62701".to_string(),
    );

    let location = Location::new_physical(
        location_id,
        "Test Office".to_string(),
        address.clone(),
    ).unwrap();

    assert_eq!(location.name, "Test Office");
    assert_eq!(location.location_type, LocationType::Physical);
    assert_eq!(location.address, Some(address));
}

#[test]
fn test_coordinate_distance() {
    // New York City
    let nyc = GeoCoordinates::new(40.7128, -74.0060);

    // Los Angeles
    let la = GeoCoordinates::new(34.0522, -118.2437);

    let distance = nyc.distance_to(&la);

    // Should be approximately 3,944 km
    assert!((distance - 3_944_000.0).abs() < 10_000.0);
}
EOF

echo "Location domain extraction structure created!"
echo "Next steps:"
echo "1. Manually extract remaining location code from cim-domain"
echo "2. Update imports in the extracted files"
echo "3. Remove location code from cim-domain"
echo "4. Add cim-domain-location to workspace Cargo.toml"
echo "5. Initialize as git submodule"
