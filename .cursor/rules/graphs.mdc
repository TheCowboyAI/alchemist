---
description: Graphs in CIM
globs: *.rs
alwaysApply: false
---

# EventStore-CQRS-Graph + Bevy v0.16 Integration Best Practices

## Core Architecture Principles

- **NATS JetStream Event Store**: Primary source of truth with CID-chained events
- **CQRS Pattern**: Separated write model (commands) and read model (queries)
- **Petgraph Storage**: Lightweight graph structure with component deduplication
- **Bevy ECS Visualization**: Real-time rendering through async/sync bridge
- **Decoupled Layers**:
  ```rust
  struct GraphSystem {
      event_store: EventStore,        // NATS JetStream persistence
      write_model: GraphAggregate,    // Command processing
      read_model: GraphReadModel,     // Query optimization
      bevy_bridge: AsyncSyncBridge,   // Real-time updates
  }
  ```

## EventStore with CID Chains

### Event Structure
```rust
#[derive(Serialize, Deserialize)]
pub struct DomainEvent {
    pub event_id: EventId,
    pub aggregate_id: AggregateId,
    pub event_type: String,
    pub payload: serde_json::Value,
    pub sequence: u64,
    pub timestamp: SystemTime,
    pub event_cid: Option<Cid>,      // Content-addressed identifier
    pub previous_cid: Option<Cid>,   // Chain to previous event
    pub metadata: EventMetadata,
}

// CID calculation ensures integrity
pub fn calculate_event_cid(
    payload: &[u8],
    previous_cid: Option<Cid>,
    aggregate_id: &AggregateId,
    event_type: &str,
    timestamp: SystemTime,
) -> Result<Cid, EventStoreError> {
    // Uses IPLD dag-cbor format
}
```

### EventStream Transactions
```rust
pub struct EventStreamTransaction {
    pub transaction_id: TransactionId,
    pub sequence_range: SequenceRange,
    pub aggregate_id: AggregateId,
    pub events: Vec<DomainEvent>,
    pub metadata: TransactionMetadata,
}

// Atomic event processing
let transaction = event_service.fetch_transaction(
    aggregate_id,
    TransactionOptions {
        replay_policy: ReplayPolicy::FromBeginning,
        max_events: Some(1000),
    },
).await?;
```

## CQRS Implementation

### Write Model (Commands)
```rust
pub struct GraphAggregate {
    id: GraphId,
    graph: petgraph::Graph<NodeId, EdgeId>,
    nodes: DashMap<NodeId, NodeEntity>,
    component_indices: ComponentIndices,
}

// Command processing
impl GraphAggregate {
    pub async fn handle_command(&mut self, cmd: GraphCommand) -> Result<Vec<DomainEvent>, Error> {
        match cmd {
            GraphCommand::AddNode { node } => {
                // Validate business rules
                // Generate events
                // Update state
            }
        }
    }
}
```

### Read Model (Queries)
```rust
pub struct GraphReadModel {
    node_views: DashMap<NodeId, NodeView>,
    metrics: Arc<RwLock<GraphMetrics>>,
    query_cache: QueryCache,
}

// Optimized queries
impl GraphReadModel {
    pub fn find_nodes_with_component(
        &self,
        component_type: ComponentType,
        criteria: ComponentCriteria,
    ) -> Result<Vec<NodeView>, QueryError> {
        // Use pre-computed indices
        // Return from cache if available
    }
}
```

## Component Deduplication Strategy

### Memory-Optimized Storage
```rust
// Flyweight pattern for 60-80% memory reduction
pub struct ComponentStorage {
    components: HashMap<ComponentId, Arc<Component>>,
    reference_counts: HashMap<ComponentId, usize>,
}

pub struct NodeEntity {
    pub id: NodeId,
    pub component_ids: HashSet<ComponentId>,  // References, not copies
}

// Before: 500+ bytes per node
// After: 64 bytes per node + shared components
```

## Async/Sync Bridge

### Bridge Architecture
```rust
pub struct AsyncSyncBridge {
    // Commands: Bevy (sync) → NATS (async)
    command_tx: crossbeam::channel::Sender<BridgeCommand>,
    command_rx: Arc<Mutex<crossbeam::channel::Receiver<BridgeCommand>>>,

    // Events: NATS (async) → Bevy (sync)
    event_tx: tokio::sync::mpsc::UnboundedSender<BridgeEvent>,
    event_rx: crossbeam::channel::Receiver<BridgeEvent>,
}

// Batched event processing
impl AsyncSyncBridge {
    pub fn receive_events(&self) -> Vec<BridgeEvent> {
        // Batch events for efficiency
        // Respect timeout for low latency
    }
}
```

## Bevy Integration Patterns

### ECS Components
```rust
#[derive(Component)]
pub struct GraphNode {
    node_id: NodeId,
    graph_index: NodeIndex<u32>,
}

#[derive(Component)]
pub struct GraphEdge {
    edge_id: EdgeId,
    source: Entity,
    target: Entity,
}

#[derive(Component)]
pub struct GraphReference {
    aggregate_id: AggregateId,
    last_event_cid: Option<Cid>,
}
```

### Event Processing Systems
```rust
fn poll_graph_events(
    bridge: Res<AsyncSyncBridge>,
    mut commands: Commands,
    mut graph_events: EventWriter<GraphMutationEvent>,
) {
    let events = bridge.receive_events();

    for event in events {
        match event {
            BridgeEvent::NodeAdded { graph_id, node_id, event_cid } => {
                // Spawn entity
                // Update visualization
                graph_events.send(GraphMutationEvent::NodeAdded {
                    graph_id,
                    node_id,
                });
            }
            // Handle other events
        }
    }
}
```

## Performance Optimization

### Query Performance
```rust
// Sub-10ms query latency through:
// 1. Pre-computed indices
// 2. LRU cache with TTL
// 3. Parallel query execution

pub struct QueryCache {
    cache: Arc<RwLock<LruCache<QueryKey, QueryResult>>>,
    hit_rate: Arc<AtomicU64>,
}
```

### Memory Efficiency
```rust
// Component deduplication
// - 80% reduction for similar components
// - Reference counting for lifecycle
// - Bloom filters for fast lookups

pub struct ComponentIndices {
    type_index: HashMap<ComponentType, HashSet<NodeId>>,
    category_index: HashMap<String, HashSet<NodeId>>,
    bloom_filter: BloomFilter<ComponentId>,
}
```

## Snapshot Management

### Fast Recovery
```rust
pub struct SnapshotService {
    object_store: NatsObjectStore,
    compression: CompressionType::Zstd,
}

impl SnapshotService {
    pub async fn create_snapshot(&self, graph: &GraphAggregate) -> Result<Cid, Error> {
        // Serialize graph state
        // Compress with zstd
        // Store in NATS Object Store
        // Return CID for retrieval
    }

    pub async fn restore_from_snapshot(&self, cid: Cid) -> Result<GraphAggregate, Error> {
        // Fetch from object store
        // Decompress
        // Reconstruct graph
    }
}
```

## Operational Guidelines

1. **Event Ordering**:
   - Maintain strict sequence per aggregate
   - Use CID chains for integrity verification
   - Handle out-of-order events gracefully

2. **Memory Management**:
   - Monitor component deduplication ratio
   - Set bounded buffers (10K events default)
   - Use snapshots for long-running graphs

3. **Performance Monitoring**:
   ```rust
   pub struct GraphMetrics {
       event_lag_ms: Histogram,
       query_latency_p99: Gauge,
       cache_hit_ratio: Gauge,
       memory_usage_mb: Gauge,
   }
   ```

4. **Error Recovery**:
   - Automatic retry with exponential backoff
   - Circuit breakers for downstream services
   - Snapshot-based recovery for corruption

## Testing Patterns

### CID Chain Verification
```rust
#[tokio::test]
async fn test_event_chain_integrity() {
    let event1 = store.append_event(...).await?;
    let event2 = store.append_event(...).await?;

    assert_eq!(event2.previous_cid, event1.event_cid);
    assert!(verify_cid_chain(&[event1, event2])?);
}
```

### CQRS Consistency
```rust
#[test]
fn test_eventual_consistency() {
    // Write through command
    write_model.process_command(AddNode { ... })?;

    // Wait for projection
    tokio::time::sleep(Duration::from_millis(100)).await;

    // Read model should reflect change
    let node = read_model.get_node(node_id)?;
    assert!(node.is_some());
}
```

## Configuration

### NATS JetStream
```yaml
jetstream:
  store_dir: "./data/jetstream"
  max_memory_store: 1GB
  max_file_store: 10GB

streams:
  - name: event-store
    subjects: ["event.store.>"]
    retention: limits
    max_age: 365d
```

### Performance Tuning
```rust
pub struct GraphConfig {
    // Deduplication
    pub dedup_threshold: f32,        // 0.8 = 80% similarity
    pub dedup_batch_size: usize,     // 1000 components

    // Caching
    pub cache_size: usize,           // 10_000 entries
    pub cache_ttl: Duration,         // 5 minutes

    // Batching
    pub event_batch_size: usize,     // 100 events
    pub batch_timeout: Duration,     // 10ms

    // Snapshots
    pub snapshot_interval: u64,      // Every 1000 events
    pub snapshot_compression: bool,  // true (zstd)
}
```

This architecture provides a high-performance, memory-efficient graph system with cryptographic integrity through CID chains, optimized query performance through CQRS, and real-time visualization through Bevy ECS.
