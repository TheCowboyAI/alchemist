---
description: DDD Best Practices
globs:
alwaysApply: true
---

You are an expert in Domain-Driven Design (DDD) for event-driven architectures, particularly focused on Rust, NATS, and distributed systems.

# Domain-Driven Design Naming Convention Guideline

This document establishes strict and comprehensive naming conventions for all code, documentation, and event structures within a Domain-Driven Design (DDD) project. The goal is to enforce clarity, consistency, and alignment with the Ubiquitous Language.

---

## **1. Ubiquitous Language**

- **All names must be derived from the business domain vocabulary.**
  - Example: Use `Invoice` instead of `InvoiceEntity` or `InvoiceComponent` or `InvoiceDTO` unless "Entity" or "DTO" are explicit business terms.
- **Avoid technical terms and suffixes unless they are part of the domain language.**
  - Example: Do not use `Manager`, `Helper`, or `Processor` unless these are business terms.
- **Collaborate with domain experts to validate names and maintain a shared glossary**.
- **Names must be clear, pronounceable, and free from uninterpretable acronyms.**
- **Compound Names should be natural phrases with no whitespace and PascalCase**
- **Keep names as concise and specific as possible**.

---

## **2. Aggregates and Entities**

- **Aggregates are named as singular nouns.**
  - Example: `Order`, `User`.
- **Entities within aggregates are also named as singular nouns.**
  - Example: `OrderItem` (part of the `Order` aggregate).
- **Avoid technical suffixes unless required by the domain.**
  - Example: Use `Order`, not `OrderAggregate`, unless "Aggregate" is a business term.

---

## **3. Domain Services**

- **Domain services are named as `ServiceContext`.**
  - Example: `AuthorizeUserRegistration`, `ApproveInvoice`.
- **Application services are named as `ServiceContext`.**
  - Example: `UserRegistration` (application layer).
- **Services should NOT reflect a hierarchy.**
---

## **4. Repositories**

- **Repositories are named as `DomainContext`.**
  - Example: `Orders`, `People`, `Organizations`.
- **Avoid generic or ambiguous repository names.**
  - Example: Do not use `Data` or `GenericRepository`.

---

## **5. Value Objects**

- **Value objects are named as descriptive nouns or noun phrases.**
  - Example: `Address`, `TimeRange`.
- **Value objects must be immutable and clearly distinguish themselves from entities.**
  - Example: `Address` (value object), `User` (entity).

---

## **6. Domain Events**

- **Domain events are preceeded in Subject as `event.` so we should not repeat that pattern in the name.**
  - Example: `MoneyDeposited`, `OrderPlaced`.
- **Events must be specific to the action and subject.**
  - Example: Use `OrderShipped`, not `OrderChanged`.
- **Event payloads should be minimal, immutable, and use primitive types or simple DTOs**.
- **Event payloads may also be a CID, referring to an Object in the Object Store**.
- **Event names must be serializable and independent of domain model classes.**

---

## **7. Event-Driven Architecture (Topic/Queue Naming)**

- **Events related to collections or aggregates use plural names.**
  - Example: `payments.failed`, `users.registered`.
- **Events related to processes or single entities use singular names.**
  - Example: `transaction.authorised`, `authentication.failed`.
- **IF Including a version, so do so at the END of the topic name.**
  - Example: `domain.event.v1` or `domain.event.v0.2.1`.
- **For sub-entities or nested concepts, use plural for collections.**
  - Example: `order.items.shipped`.
- **Avoid embedding technical details or generic terms in event names.**

---

## **8. Intention-Revealing Interfaces**

- **Interfaces and classes must reveal intent through their names.**
  - Example: `CompleteInvoiceApproval`, not `InvoiceService`.
- **Avoid generic or ambiguous names.**
  - Example: Use `AutomatedInvoiceApproval`, not `InvoiceProcessor`.
- **Interfaces should be Atomic**
- **Interfaces may be Composed**
---

## **9. Bounded Contexts**

- **Concepts must be isolated within their bounded context.**
  - Example: `Candidate` in "sourcing" context vs. `Prospect` in "interview" context.
- **Use context-specific names to avoid ambiguity.**
  - Example: `Prospect`, `Candidate`, `Employee` for different stages.

---

## **10. Naming Process and Documentation**

- **All naming conventions must be documented in a shared glossary.**
- **Names must be reviewed and validated by both developers and domain experts**.
- **Use collaborative modeling techniques (e.g., Event Storming) to refine names iteratively**.
- **REFACTOR NAMES AS THE DOMAIN UNDERSTANDING EVOLVES.**

---

## **11. Enforcement and Tools**

- **Use linters, style guides, or static analysis tools to enforce naming conventions.**
- **DOCUMENT EXCEPTIONS AND RATIONALE FOR ANY DEVIATION FROM THE STANDARD.**
- **Regularly audit code and documentation for compliance.**

---

This guideline ensures that naming within your project is Domain-Driven Design consistent, domain-aligned, and maintainable.

**ADHERE STRICTLY TO THESE RULES TO MINIMIZE AMBIGUITY AND MAXIMIZE CLARITY**.

# Domain-Driven Design Best Practices

## Strategic Design Patterns

### Bounded Context Guidelines
- **Bounded Context**: Logical boundary containing a unified model with its own ubiquitous language
- Each bounded context should have a single responsibility and clear ownership
- Contexts communicate only through well-defined interfaces (events, APIs, commands)
- Never share domain models directly between contexts
- Use Anti-Corruption Layers (ACL) when integrating with external systems

### Domain and Subdomain Boundaries
- **Domain**: The entire problem space the software addresses
- **Subdomain**: Distinct areas within the domain (Core, Supporting, Generic)
- **Core Domain**: The primary business differentiator - invest most effort here
- **Supporting Domain**: Necessary but not differentiating - simplify or outsource
- **Generic Domain**: Common functionality - use off-the-shelf solutions

## Tactical Design Patterns

### Entity Guidelines
- **Identity**: Must have a unique identifier that persists throughout its lifecycle
- **Mutability**: Can change state while maintaining identity
- **Lifecycle**: Has creation, modification, and potentially deletion phases
- Name with business-meaningful nouns (Customer, Order, Product)

### Value Object Guidelines
- **Immutability**: Cannot change after creation - create new instances instead
- **Equality**: Compared by value, not identity
- **Self-validation**: Ensure invariants in constructor
- Name with descriptive nouns (Money, Address, Email, ProductCode)

### Aggregate Guidelines
- **Consistency Boundary**: Enforce business rules and invariants
- **Single Root**: Only the aggregate root can be referenced from outside
- **Size**: Keep small - prefer multiple small aggregates over large ones
- **Transactions**: One aggregate per transaction to avoid distributed locks
- **Loading**: Load entire aggregate, not partial data

### Domain Event Guidelines
- **Naming**: Use past tense verbs (OrderPlaced, PaymentProcessed, UserRegistered)
- **Timing**: Raise events AFTER successful state changes
- **Content**: Include relevant data, but avoid exposing internal aggregate state
- **Immutability**: Events should be immutable once created
- **Versioning**: Plan for event schema evolution

## Event-Driven Communication Patterns

### Between Bounded Contexts
- Use **Domain Events** for eventual consistency
- Prefer **publish/subscribe** over point-to-point communication
- Events should be business-meaningful, not technical artifacts
- Include correlation IDs for tracing across contexts

### Within Bounded Context
- Use **Commands** for direct operations within the context
- **Policies** encapsulate business rules that react to events
- **Read Models** provide optimized views for queries

## Naming Conventions and Boundaries

### Clear Boundary Definitions
- **Actor**: External entities that interact with the system (User, System, External Service)
- **System**: Technical boundaries and integration points
- **UI**: Presentation layer concerns and user interactions
- **Command**: Imperative requests to change state (CreateOrder, ProcessPayment)
- **Policy**: Business rules that determine reactions (RefundPolicy, DiscountPolicy)
- **Opportunity**: Areas for improvement or extension points
- **Hotspot/Bottleneck**: Performance or scalability concerns requiring attention


## Rust-Specific DDD Patterns

### Type Safety for Domain Concepts
- Use newtype patterns for domain identifiers: `struct OrderId(Uuid)`
- Leverage enum for domain states: `enum OrderStatus { Pending, Confirmed, Shipped }`
- Use Result for operations that can fail
- Implement domain validation in constructors

### Event Handling with NATS
- Define events as serializable structs with serde
- Use NATS subjects that map to domain concepts: `orders.placed`, `payments.processed`
- Implement event handlers as separate services/modules
- Use message durability for critical business events

## Composition in Bounded Contexts

### Context Integration Patterns
1. **Shared Kernel**: Limited shared code between contexts (use sparingly)
2. **Customer/Supplier**: One context depends on another's API
3. **Anti-Corruption Layer**: Translate between different models
4. **Open Host Service**: Provide well-defined API for integration
5. **Published Language**: Common event schema across contexts

### Event Choreography vs Orchestration
- **Choreography**: Each service knows what to do when events occur (preferred for loose coupling)
- **Orchestration**: Central coordinator manages workflow (use for complex multi-step processes)

## Workflow Communication Guidelines

### Event Flow Design
1. **Command** → **Aggregate** → **Domain Event** → **Policy/Handler** → **New Command/Event**
2. Keep event chains short and understandable
3. Use correlation IDs to track business processes across contexts
4. Implement proper error handling and compensation patterns

### Eventual Consistency Patterns
- Accept that different contexts may have different views of data
- Use **State Machine Pattern** for complex multi-context transactions
- Implement **Outbox Pattern** for reliable event publishing
- Design for **idempotency** in event handlers

## Best Practices Summary

1. **Start with Events**: Identify domain events first, then build aggregates around them
2. **Protect Invariants**: Only aggregates should enforce business rules
3. **Embrace Autonomy**: Each bounded context should be independently deployable
4. **Design for Change**: Use events for integration to allow contexts to evolve
5. **Monitor and Observe**: Track event flows and business metrics across contexts
6. **Test Boundaries**: Write integration tests that verify context interactions
7. **Document Relationships**: Maintain context maps showing integration patterns

## Anti-Patterns to Avoid

- **Anemic Domain Model**: Avoid entities with only getters/setters
- **God Aggregate**: Don't create massive aggregates that do everything
- **Chatty Integration**: Minimize synchronous calls between contexts
- **Shared Database**: Each context should own its data
- **Generic Events**: Events should be specific to business concepts
- **Missing Boundaries**: Clearly define what belongs to each context
```

## Composing Bounded Contexts for Event-Driven Workflows

Based on the DDD elements and the CIM architecture, here's how to effectively compose bounded contexts that communicate through events:

**Context Boundary Definition**

Each bounded context should encapsulate related **Aggregates**, **Policies**, and **Read Models** that serve a specific business capability. For example, in a CIM system:

- **Agent Management Context**: Handles Actor registration, capabilities, and lifecycle
- **Message Routing Context**: Manages NATS communication patterns and routing
- **Knowledge Context**: Maintains embeddings, conceptual spaces, and relationships
- **Workflow Context**: Orchestrates multi-agent interactions and processes

**Event-Driven Communication Patterns**

Contexts communicate exclusively through **Domain Events** published to NATS subjects[3][8]. When an **Actor** issues a **Command** within a context, it may trigger a **Domain Event** that other contexts subscribe to. **Policies** within each context determine how to react to incoming events, potentially issuing new **Commands** or triggering additional events.

**Workflow Composition**

Complex business processes span multiple contexts through event choreography[6]. Each context publishes events when significant business activities occur, and other contexts react according to their **Policies**. This creates loosely coupled workflows where contexts remain autonomous yet collaborate effectively.

**Identifying Hotspots and Opportunities**

The **Hotspot/Bottleneck** and **Opportunity** elements help identify where context boundaries might need adjustment or where new capabilities should be added. Monitor event volumes and processing times to detect bottlenecks, and use **Opportunities** to guide the evolution of your context boundaries as the system grows.

This approach ensures your CIM architecture maintains clear boundaries while enabling sophisticated agent collaboration through well-defined event flows across your distributed system.
