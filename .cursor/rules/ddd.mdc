---
description: DDD Best Practices
globs:
alwaysApply: true
---

# Domain-Driven Design Naming Convention Guideline

This document establishes strict and comprehensive naming conventions for all code, documentation, and event structures within a Domain-Driven Design (DDD) project. The goal is to enforce clarity, consistency, and alignment with the Ubiquitous Language.

---

## **1. Ubiquitous Language**

- **All names must be derived from the business domain vocabulary.**
  - Example: Use `Invoice` instead of `InvoiceEntity` or `InvoiceComponent` or `InvoiceDTO` unless "Entity" or "DTO" are explicit business terms.
- **Avoid technical terms and suffixes unless they are part of the domain language.**
  - Example: Do not use `Manager`, `Helper`, or `Processor` unless these are business terms.
- **Collaborate with domain experts to validate names and maintain a shared glossary**.
- **Names must be clear, pronounceable, and free from uninterpretable acronyms.**
- **Compound Names should be natural phrases with no whitespace and PascalCase**
- **Keep names as concise and specific as possible**.

---

## **2. Aggregates and Entities**

- **Aggregates are named as singular nouns.**
  - Example: `Order`, `User`.
- **Entities within aggregates are also named as singular nouns.**
  - Example: `OrderItem` (part of the `Order` aggregate).
- **Avoid technical suffixes unless required by the domain.**
  - Example: Use `Order`, not `OrderAggregate`, unless "Aggregate" is a business term.

---

## **3. Domain Services**

- **Domain services are named as `ServiceContext`.**
  - Example: `AuthorizeUserRegistration`, `ApproveInvoice`.
- **Application services are named as `ServiceContext`.**
  - Example: `UserRegistration` (application layer).
- **Services should NOT reflect a hierarchy.**
---

## **4. Repositories**

- **Repositories are named as `DomainContext`.**
  - Example: `Orders`, `People`, `Organizations`.
- **Avoid generic or ambiguous repository names.**
  - Example: Do not use `Data` or `GenericRepository`.

---

## **5. Value Objects**

- **Value objects are named as descriptive nouns or noun phrases.**
  - Example: `Address`, `TimeRange`.
- **Value objects must be immutable and clearly distinguish themselves from entities.**
  - Example: `Address` (value object), `User` (entity).

---

## **6. Domain Events**

- **Domain events are preceeded in Subject as `event.` so we should not repeat that pattern in the name.**
  - Example: `MoneyDeposited`, `OrderPlaced`.
- **Events must be specific to the action and subject.**
  - Example: Use `OrderShipped`, not `OrderChanged`.
- **Event payloads should be minimal, immutable, and use primitive types or simple DTOs**.
- **Event payloads may also be a CID, referring to an Object in the Object Store**.
- **Event names must be serializable and independent of domain model classes.**

---

## **7. Event-Driven Architecture (Topic/Queue Naming)**

- **Events related to collections or aggregates use plural names.**
  - Example: `payments.failed`, `users.registered`.
- **Events related to processes or single entities use singular names.**
  - Example: `transaction.authorised`, `authentication.failed`.
- **IF Including a version, so do so at the END of the topic name.**
  - Example: `domain.event.v1` or `domain.event.v0.2.1`.
- **For sub-entities or nested concepts, use plural for collections.**
  - Example: `order.items.shipped`.
- **Avoid embedding technical details or generic terms in event names.**

---

## **8. Intention-Revealing Interfaces**

- **Interfaces and classes must reveal intent through their names.**
  - Example: `CompleteInvoiceApproval`, not `InvoiceService`.
- **Avoid generic or ambiguous names.**
  - Example: Use `AutomatedInvoiceApproval`, not `InvoiceProcessor`.
- **Interfaces should be Atomic**
- **Interfaces may be Composed**
---

## **9. Bounded Contexts**

- **Concepts must be isolated within their bounded context.**
  - Example: `Candidate` in "sourcing" context vs. `Prospect` in "interview" context.
- **Use context-specific names to avoid ambiguity.**
  - Example: `Prospect`, `Candidate`, `Employee` for different stages.

---

## **10. Naming Process and Documentation**

- **All naming conventions must be documented in a shared glossary.**
- **Names must be reviewed and validated by both developers and domain experts**.
- **Use collaborative modeling techniques (e.g., Event Storming) to refine names iteratively**.
- **REFACTOR NAMES AS THE DOMAIN UNDERSTANDING EVOLVES.**

---

## **11. Enforcement and Tools**

- **Use linters, style guides, or static analysis tools to enforce naming conventions.**
- **DOCUMENT EXCEPTIONS AND RATIONALE FOR ANY DEVIATION FROM THE STANDARD.**
- **Regularly audit code and documentation for compliance.**

---

This guideline ensures that naming within your project is Domain-Driven Design consistent, domain-aligned, and maintainable.

**ADHERE STRICTLY TO THESE RULES TO MINIMIZE AMBIGUITY AND MAXIMIZE CLARITY**.
